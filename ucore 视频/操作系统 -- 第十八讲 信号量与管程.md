## 信号量

### 回顾

- 并发问题
    - 多线程并发导致资源竞争
- 同步概念
    - 协调多线程对共享数据的访问
    - 任何时刻只能够有一个线程执行临界区代码
- 确保同步正确的方法
    - 底层硬件支持
    - 高层次的编程抽象

<img src="img/操作系统 -- 第十八讲 信号量与管程-1.png" />

### 信号量（semaphore）

- 信号量是操作系统提供的一种协调共享资源访问的方法
    - 软件同步时平等线程间的一种同步协商机制
    - OS 是管理者，地位高于进程
    - 用信号量表示系统资源的数量
- 由 Dijkstra 在 20 世纪 60 年代提出
- 早期的操作系统的主要同步机制
    - 现在很少用（但还是非常重要在计算机科学研究）
- 信号是一种抽象数据类型
    - 有一个整形（sem）变量和两个原子操作组成
    - **P()**（Prolaag （荷兰语尝试减少））
        - sem 减 1
        - 如 sem < 0，进入等待，否则继续
    - **V()**（Verhoog （荷兰语增加））
        - sem 加 1
        - 如 sem ≤ 0，唤醒一个等待进程
- 信号量与铁路的类比
    - 2 个站台的车站
    - 2 个资源的信号量

### 信号量的特性

- 信号量是**被保护**的**整数**变量
    - 初始化完成后，只能通过 P() 和 V() 操作修改
    - 由操作系统保证，PV 操作时原子操作
- **P() 可能阻塞**，V() 不会阻塞
- 通常假定信号量是 “公平的”
    - 线程不会被无限期阻塞在 P() 操作
    - 假定信号量等待按先进先出排队

### 信号量的实现

<img src="img/操作系统 -- 第十八讲 信号量与管程-2.png" />

## 信号量使用

### 信号量分类

- 可分为两种信号量
    - **二进制信号量**：资源数目为 0 或 1
    - **资源信号量**：资源数目为任何非负值
    - 两者等价
        - 基于一个可以实现另一个
- 信号量的使用
    - 互斥访问
        - 临界区的互斥访问控制
    - 条件同步
        - 线程间的事件等待

### 用信号量实现临界区的互斥访问

每类资源设置一个信号量，其初值为 1

```c
mutex = new Semaphore(1);
```

```c
mutex->P();  // 申请
Critical Section;
mutex->V();  // 释放
```

- 必须**成对使用** P() 操作和 V() 操作
    - P() 操作保证互斥访问临界资源
    - V() 操作在使用后释放临界资源
    - PV 操作不能次序错误、重复或遗漏

### 用信号量实现条件同步

条件同步设置一个信号量，其初值为 0

<img src="img/操作系统 -- 第十八讲 信号量与管程-3.png" />

### 生产者-消费者问题

<img src="img/操作系统 -- 第十八讲 信号量与管程-4.png" />

- 有界缓冲区的生产者-消费者的问题描述
    - 一个或多个**生产者**在生成数据后放在一个缓冲区里
    - 单个**消费者**从缓冲区取出数据处理
    - 任何时刻**只能有一个**生产者或消费者可访问缓冲区

### 用信号量解决生产者-消费者问题

- 问题分析
    - 任何时刻只能有一个线程操作缓冲区（互斥访问）
    - 缓冲区空时，消费者必须等待生产者（条件同步）
    - 缓冲区满时，生产者必须等待消费者（条件同步）
- 用信号量描述每个约束
    - 二进制信号量 mutex
    - 资源信号量 fullBuffers
    - 资源信号量 emptyBuffers

<img src="img/操作系统 -- 第十八讲 信号量与管程-5.png" />

- P、V 操作的顺序有影响吗？

### 使用信号量的困难

- 读/开发代码比较困难
    - 程序员需要能运用信号量机制
- 容易出错
    - 使用的信号量已经被另一个线程占用
    - 忘记释放信号量
- 不能够处理死锁问题

### 练习题

- 2 元信号量可以初始化为 **0 或 1**
- 多个进程对信号量 S 进行了 6 次 P 操作，2 次 V 操作后，现在信号量的值是 -3，与信号量 S 相关的处于阻塞状态的进程有 **3** 个

## 管程

- 管程是一种用于多线程互斥访问共享资源的程序结构
    - 采用面向对象方法，简化了线程间的同步控制
    - 任一时刻最多只有一个线程执行管程代码
    - 正在管程中的线程可临时放弃管程的互斥访问，等待事件的恢复
- 管程的使用
    - 在对象/模块中，收集相关共享数据
    - 定义访问共享数据的方法

### 管程的组成

- 一个锁
    - 控制管程代码的互斥访问
- 0 或者多个条件变量
    - 管理共享数据的并发访问

<img src="img/操作系统 -- 第十八讲 信号量与管程-6.png" />

### 条件变量（Condition Variable）

- 条件变量是管程内的等待机制
    - 进入管程的线程因资源被占用而进入等待状态
    - 每个条件变量表示一种等待原因，对应一个等待队列
- Wait() 操作
    - 将自己阻塞在等待队列中
    - 唤醒一个等待者或释放管程的互斥访问
- Signal() 操作
    - 将等待队列中的一个线程唤醒
    - 如果等待队列为空，则等同空操作

<img src="img/操作系统 -- 第十八讲 信号量与管程-7.png" />

### 用信号量解决生产者-消费者问题

<img src="img/操作系统 -- 第十八讲 信号量与管程-8.png" />

### 管程条件变量的释放处理方式

<img src="img/操作系统 -- 第十八讲 信号量与管程-9.png" />

- Hansen 管程比 Hoare 管程少了一次上下文切换
- Hansen 管程主要用于真实 OS 和 Java 中
- Hoare 管程主要见于教材中

### Hansen 管程与 Hoare 管程

<img src="img/操作系统 -- 第十八讲 信号量与管程-10.png" />

