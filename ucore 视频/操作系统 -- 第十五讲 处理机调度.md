## 处理机调度概念

### CPU 资源的时分复用

- 进程切换：CPU 资源的当前占用者切换

    - 保存当前进程在 PCB 中的执行上下文（CPU 状态）

    - 恢复下一个进程的执行上下文

- 处理机调度

    - 从就绪队列中**挑选**下一个占用 CPU 运行的**进程**
    - 从多个可用 CPU 中**挑选**就绪进程可使用的 CPU **资源**

- 调度程序：挑选就绪进程的内核函数

    - 调度策略
        - 依据什么原则挑选进程/线程？
    - 调度时机
        - 什么时候进程调度？

### 调度时机

- 在进程/线程的生命周期中的什么时候进行调度？
- 内核运行调度的条件
    - 进程从运行状态切换到等待状态
    - 进程被终结了
- 非抢占系统
    - 当前进程主动放弃 CPU 时
- 可抢占系统
    - 中断请求被服务例程相应完成时
    - 当前进程被抢占
        - 进程时间片用完
        - 进程从等待切换到就绪

## 调度准则

### 调度策略

- 调度策略
    - 确定如何从就绪队列中选择下一个执行进程
- 调度策略要解决的问题
    - 挑选就绪队列中的哪一个进程？
    - 通过什么样的准则来选择？
- 调度算法
    - 在调度程序中实现的调度策略
- 比较调度算法的准则
    - 哪一个策略/算法较好？

### 处理机资源的使用模式

- 进程在 CPU 计算和 I/O 操作间交替
    - 每次调度决定在下一个 CPU 计算时将哪个工作交给 CPU
    - 在时间片机制下，进程可能在结束当前 CPU 计算前被迫放弃 CPU

<img src="img\操作系统 -- 第十五讲 处理机调度-1.png" />

### 比较调度算法的准则

- CPU 使用率
    - CPU 处于忙状态的**时间百分比**
- 吞吐量
    - 单位时间内完成的**进程数量**
- 周转时间
    - 进程从初始化到结束（包括等待）的**总时间**
- 等待时间
    - 进程在就绪队列中的**总时间**
- 响应时间
    - 从提交请求到产生响应所花费的**总时间**

### 吞吐量与延迟

- 调度算法的要求
    - 希望 “**更快**” 的服务
- 什么是更快？
    - 传输文件时的**高带宽**，调度算法的**高吞吐量**
    - 玩游戏时的**低延迟**，调度算法的**低响应延迟**
    - 这两个因素是独立的
- 与**水管**的类比
    - 低延迟：**喝水**的时候想要一打开水龙头水就流出来
    - 高带宽：**给游泳池充水**时希望从水龙头里同时流出大量的水，并且不介意是否存在延迟

### 处理机调度策略的相应时间目标

- 减少响应时间
    - 及时处理用户的输入请求，尽快将输出反馈给用户
- 减少平均响应时间的波动
    - 在交互系统中，可预测性比高差异低平均更重要
- 低延调度改善了用户的交互体验
    - 如果移动鼠标时，屏幕中的光标没动，用户可能会重启电脑
- 响应时间是操作系统的计算延迟

### 处理机调度策略的吞吐量目标

- 增加吞吐量
    - 减少开销（操作系统开销，上下文切换）
    - 系统资源的高效利用（CPU，I/O 设备）
- 减少等待时间
    - 减少每个进程的等待时间
- 操作系统需要保证吞吐量不受用户交互的影响
    - 操作系统必须不时进行调度，即使存在许多交互任务
- 吞吐量是操作系统的计算带宽

### 处理机调度的公平性目标

- 公平的定义
    - 保证每个进程占用相同的 CPU 时间
        - 这公平么？
        - 一个用户比其他用户运行更多的进程时，怎么办？
    - 保证每个进程的等待时间相同
- 公平通常会增加平均响应时间

## 先来先服务、短进程优先和最高响应比优先调度算法

### 调度算法

- 先来先服务算法
    - FCFS: First Come, First Served
- 短进程优先算法
    - SPN: Shortest Process Next
    - SJF: Shortest Job First（短作业优先算法）
    - SRT: Shortest Remaining Time（短剩余时间优先算法）
- 最高响应比优先算法
    - HRRN: Highest Response Ratio Next
- 时间片轮转算法
    - RR: Round Robin
- 多级反馈队列算法
    - MFQ: Multilevel Feedback Queues
- 公平共享调度算法
    - FSS: Fair Share Scheduling

### 先来先服务算法（First Come, First Served, FCFS）

- 依据进程进入就绪状态的先后顺序排列

    - 进程进入等待或结束状态时，就绪队列中的下一个进程占用 CPU

- FSFC 算法的周转时间

    - 示例：3 个进程，计算时间分别为 12，3，3

        <img src="img\操作系统 -- 第十五讲 处理机调度-2.png" style="zoom:80%;" />

### 先来先服务算法的特征

- 优点
    - 简单
- 缺点
    - 平均等待时间波动较大
        - 短进程可能排在长进程后面
    - I/O 资源和 CPU 资源的利用率较低
        - CPU 密集型进程会导致 I/O 设备闲置时，I/O 密集型进程也等待

### 短进程优先算法（SPN）

- 选择就绪队列中执行时间最短进程占用 CPU 进入运行状态

    - 就绪队列按预期的执行时间来排序

        <img src="img\操作系统 -- 第十五讲 处理机调度-3.png" />

- 短剩余时间优先算法（SRT）

    - SPN 算法的可抢占改进

### 短进程优先算法具有最优平均周转时间

- SPN 算法中一组进程的平均周转时间

    <img src="img\操作系统 -- 第十五讲 处理机调度-4.png" />

### 短进程优先算法的特征：缺点

- 可能导致饥饿
    - 连续的短进程流会使长进程无法获得 CPU 资源
- 需要预知未来
    - 如何预估下一个 CPU 计算的持续时间
    - 简单的解决办法：询问用户
        - 用户欺骗就杀死相应进程
        - 用户不知道怎么办？

### 短进程优先算法的执行时间预估

- 用历史的执行时间预估未来的执行时间

<img src="img\操作系统 -- 第十五讲 处理机调度-5.png" />

### 预估执行时间

<img src="img\操作系统 -- 第十五讲 处理机调度-6.png" />

### 最高相应比优先算法（HRRN）

- 选择就绪队列种响应比 R 值最高的进程

    R = (w + s) / s

    w：等待时间（waiting time）

    s：执行时间（service time）

    - 在短进程优先算法的基础上改进
    - 不可抢占
    - 关注进程的等待时间
    - 防止无限期推迟

- 特点

    - 有利于短作业又兼顾到长作业

## 时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架

### 时间片轮转算法（RR, Round-Robin）

- 时间片

    - 分配处理机资源的基本时间单元

        <img src="img\操作系统 -- 第十五讲 处理机调度-7.png" />

- 算法思路

    - 时间片结束时，按 FCFS 算法切换到下一个就绪进程
    - 每隔 (n - 1) 个时间片进程执行一个时间片 q

### 时间片为 20 的 RR 算法示例

<img src="img\操作系统 -- 第十五讲 处理机调度-8.png" />

### 时间片轮转算法种的时间片长度

- RR 算法开销
    - 额外的上下文切换
- 时间片太大
    - 等待时间过长
    - 极限情况退化成 FCFS
- 时间片太小
    - 反应迅速，但产生大量上下文切换
    - 大量上下文切换开销影响到系统吞吐量
- 时间片长度选择目标
    - 选择一个合适的时间片长度
    - 经验规则：维持上下文切换开销处于 1% 以内

### 比较 FCFS 和 RR

- 示例：4 个进程的执行时间如下

    P1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;53

    P2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8

    P3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;68

    P4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24
    
    假设上下文切换时间为零
    
    FCFS 和 RR 各自的平均等待时间是多少？
    
    <img src="img\操作系统 -- 第十五讲 处理机调度-9.png" />

### 多级队列调度算法（MQ）

- 就绪队列被划分成多个独立的子队列
    - 如：前台（交互）、后台（批处理）
- 每个队列拥有自己的调度策略
    - 如：前台-RR、后台-FCFS
- 队列间的调度
    - 固定优先级
        - 先处理前台，然后处理后台
        - 可能导致饥饿
    - 时间片轮转
        - 每个队列都得到一个确定的能够调度其进程的 CPU 总时间
        - 如：80%CPU 时间用于前台，20%CPU 时间用于后台

### 多级反馈队列算法（MLFQ）

- 进程可在不同队列间移动的多级队列算法

    - 时间片大小随优先级别增加而增加

    - 如进程在当前的时间片没有完成，则降到下一个优先级
- MLFQ 算法的特征
    - CPU 密集型进程的优先级下降很快
    - I/O 密集型进程停留在高优先级

<img src="img\操作系统 -- 第十五讲 处理机调度-10.png" />

### 公平共享调度（FSS. Fair Share Scheduling）

- FSS 控制用户对系统资源的访问
    - 一些用户组比其他用户组更重要
    - 保证不重要的组无法垄断资源
    - 未使用的资源按比例分配
    - 没有达到资源使用率目标的组获得更高的优先级

<img src="img\操作系统 -- 第十五讲 处理机调度-11.png" />

### 传统调度算法总结

- 先来先服务算法
    - 不公平，平均等待时间较差
- 短进程优先算法
    - 不公平，平均周转时期最小
    - 需要精确预测计算时间
    - 可能导致饥饿
- 最高响应比优先算法
    - 基于 SPN 调度
    - 不可抢占
- 时间片轮转算法
    - 公平，但是平均等待时间较差
- 多级反馈队列算法
    - 多种算法的集成
- 公平共享调度算法
    - 公平是第一要素

### ucore 的调度队列 run_queue

```c
struct run_queue {
    list_entry_t run_list;
    unsigned int proc_num;
    int max_time_slice;
    list_entry_t rq_link;
};
```

### ucore 的线程状态

<img src="img\操作系统 -- 第十五讲 处理机调度-12.png" />

### ucore 的调度时机和进程切换

<img src="img\操作系统 -- 第十五讲 处理机调度-13.png" />

### ucore 的调度算法接口 sched_class

```c
struct sched_class {
    const char *name;
    void (*init)(struct run_queue *rq);
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
    struct proc_struct *(*pick_next)(struct run_queue *rq);
    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
};
```

### ucore 调度框架

<img src="img\操作系统 -- 第十五讲 处理机调度-14.png" />

## 实时调度和多处理器调度

### 实时操作系统

- 实时操作系统的定义
    - 正确性依赖于其**时间**和**功能**两方面的操作系统
- 实时操作系统的性能指标
    - **时间约束的及时性（deadlines）**
    - 速度和平均性能相对不重要
- 实时操作系统的特性
    - 时间约束的**可预测性**

### 实时任务

- 任务（工作单元）
    - 一次计算，一次文件读取，一次信息传递等等
- 任务属性
    - 完成任务所需要的资源
    - 定时参数

<img src="img\操作系统 -- 第十五讲 处理机调度-15.png" />

### 周期实时任务

- 周期实时任务：一系列相似的任务
    - 任务有规律地重复
    - 周期 p = 任务请求时间间隔（0 < p）
    - 执行时间 e = 最大执行时间（0 < e < p）
    - 使用率 U = e / p

### 软时限和硬时限

- 硬时限（Hard deadline）
    - 错过任务时限会导致灾难性或非常严重的后果
    - 必须验证，在最坏情况下能够满足时限
- 软时限（Soft deadline）
    - 通过能满足任务时限
        - 如有时不能满足，则降低需求
    - 尽力保证满足任务时限

### 可调度性

- 可调度性表示一个实时操作系统能够满足任务时限要求
    - 需要确定实时任务的执行顺序
    - 静态优先级调度
    - 动态优先级调度

<img src="img\操作系统 -- 第十五讲 处理机调度-16.png" />

### 实时调度

- 速率单调调度算法（RM, Rate Monotinic）
    - 通过**周期**安排优先级
    - 周期越短优先级越高
    - 执行周期最短的任务
- 最早截止时间优先算法（EDF, Earliest Deadline First）
    - 截止时间越早优先级越高
    - 执行截止时间最早的任务

### 多处理器调度

- 多处理器调度的特征
    - 多个处理机组成一个多处理机系统
    - 处理机间可负载共享
- 对称多处理器（SMP, Symmetric multiprocessing）调度
    - 截止时间越早优先级越高每个处理器运行自己的调度程序
    - 调度程序对共享资源的访问需要进程同步

<img src="img\操作系统 -- 第十五讲 处理机调度-17.png" />

### 对称多处理器的进程分配

- 静态进程分配
    - 进程从开始到结束都被分配到一个固定的处理机上执行
    - 每个处理机有自己的就绪队列
    - 调度开销小
    - 各处理机可能忙闲不均
- 动态进程分配
    - 进程在执行中可分配到任意空闲处理机执行
    - 所有处理机共享一个公共的就绪队列
    - 调度开销大
    - 各处理机的负载是均衡的

## 优先级反置

### 优先级反置（Priority Inversion）

- 操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象
- 基于优先级的可抢占调度算法存在优先级反置

<img src="img\操作系统 -- 第十五讲 处理机调度-18.png" />

### 优先级继承（Priority Inheritance）

- 占用资源的低优先级进程继承申请资源的高优先级进程的优先级
    - 只有占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级

<img src="img\操作系统 -- 第十五讲 处理机调度-19.png" />

### 优先天花板协议（priority ceiling protocol）

- 占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同
    - 不管是否发生等待，都提升占用资源进程的优先级
    - 优先级高于系统中所有被锁定的资源的优先级上线，任务执行临界区时就不会被阻塞