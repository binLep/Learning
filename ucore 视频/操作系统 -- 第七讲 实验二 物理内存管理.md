## 了解x86保护模式中的特权级

### x86 特权级 - 段选择子

![](img\操作系统 -- 第七讲 实验二 物理内存管理-1.png)

### 内容摘要

![](img\操作系统 -- 第七讲 实验二 物理内存管理-2.png)

### x86 特权级 - 门描述符

![](img\操作系统 -- 第七讲 实验二 物理内存管理-3.png)

### x86 特权级 - 特权转移

![](img\操作系统 -- 第七讲 实验二 物理内存管理-4.png)

### x86 特权级 - 当前的特权级？

![](img\操作系统 -- 第七讲 实验二 物理内存管理-5.png)

**访问门时** CPL <= DPL[门] & CPL >= DPL[段]

- CPL <= DPL[门]

    - 当前的代码段（CPL）要小于门所处于的 DPL，也就是说门的特权级比较低（好比 ring 0 和 ring 3，ring 0是高特权级）

        而当前执行的代码段的特权级比较高，这样才允许通过门

- CPL >= DPL[段]
    - 通过门的目的是去访问特权级更高的段
- 该代码是为了 ring 3 的程序可以访问 ring 0 的服务

**访问段时** MAX(CPL, RPL) <= DPL[段]

- 当前的代码段（CPL）和我们要访问的数据段（ RPL）

- 我们发出的数据段特权级的请求一定要小于等于 DPL 这个段，就是当前处于代码段执行这条指令

    它发出请求，我现在处于这种状态，我要去访问某一个数据段，那么我本身的特权级要高于对应的目标

    作为使用方，我的特权级要比较高一点才能访问，那么对于数值的比较，就是 CPL 和 RPL 最大的一个值

    就是这两者最低的那个特权级要高于它所对应的目标的那个段的特权级

- 这里数值上的比较是小于等于，在实际的特权级上是大于等于
- 该代码是为了 ring 0 的服务去访问 ring 3 的程序

## 了解特权级切换过程

### x86 特权级 - 通过中断切换特权级

![](img\操作系统 -- 第七讲 实验二 物理内存管理-6.png)

### x86 特权级 - 切换特权级（0 to 3）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-7.png)

### x86 特权级 - 切换特权级（3 to 0）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-8.png)

### x86 特权级 - TSS 格式

![](img\操作系统 -- 第七讲 实验二 物理内存管理-9.png)

当一个应用程序通过不同手段从一个特权级到另一个特权级的切换之后

- 如何知道新特权级的 CS、SS 位于什么地方
    - 可以通过 IDT 描述符表来查看
- 如何知道新特权级的堆栈（SS、ESP）位于什么地方
    - 通过任务状态段（Task State Segment）来查看

### x86 特权级 - 栈切换中获取新的栈

![](img\操作系统 -- 第七讲 实验二 物理内存管理-10.png)

TSS 是一个特殊的段，位于内存中，可以通过全局描述符表来访问

![](img\操作系统 -- 第七讲 实验二 物理内存管理-11.png)

首次是全局描述符表来保存，之后依靠 Task Register 寄存器来缓存这个地址

### x86 特权级 - 建立 TSS

![](img\操作系统 -- 第七讲 实验二 物理内存管理-12.png)

## 了解段/页表

### x86 MMU - 段机制概述

![](img\操作系统 -- 第七讲 实验二 物理内存管理-13.png)

GDT 是放在内存里的，因为它占的空间比较大；硬件（MMU）来加快映射的效率

### x86 MMU - 段选择子（segment selector）中的隐藏部分

![](img\操作系统 -- 第七讲 实验二 物理内存管理-14.png)

硬件会把 ucore 中建立在 GDT 里面的段描述符中的关键信息给放在一个特殊的位置（一个隐藏的部分）

这个隐藏的部分就是我们几个寄存器（CS SS 一直到 GS），这几个寄存器有可见的 16 个 bit，也就是段寄存器的值

但是还有看不见的一大段在后边，由硬件直接控制，它里面缓存了缓存了我们的基址还有限制等等其它一些信息

### x86 hardware MMU - 建立 GDT tables（kernel init）

**lab2 建立映射关系的过程图**

![lab2 建立映射关系的过程图](img\操作系统 -- 第七讲 实验二 物理内存管理-15.png)

在 entry.S 中我们的 ucore 会建立好这个映射机制，这是操作系统第一次建立的映射机制，而这个映射的建立机制和 lab1 中 bootloader 的建立机制是不太一样的

因为 lab1 建立的是对等映射，也就是说我们的虚拟地址是 0，那么我们的物理地址我们的线性地址也是 0；我们的虚拟地址是 1000，那么我们的物理地址我们的线性地址也是 1000

lab2 中建立映射机制的时候会进行 link 的操作，在 link 的时候用到的描述文件实际上指出了它的偏移是 0xC0000000，而且还是负的

这个意思是如果我们的虚地址是 0xC0000000 的时候，实际上对应的线性地址是 0，就是这个一个映射关系

### x86 hardware MMU - 建立 GDT tables（bootloader）

**lab1 建立映射关系的过程图**

![](img\操作系统 -- 第七讲 实验二 物理内存管理-16.png)

这里建立的映射关系是对等映射，就是 0 地址对应着 0 地址，1000 对应着 1000，大致的建立过程和 lab2 的方式是类似的

唯一的不同是它用到的那个映射的关系，放在 GDT 里面的那个短描述符里面的信息是不一样的

这导致了它们两者的映射关系完全发生了变化

### x86 hardware MMU - 建立 GDT tables（使能页机制 enable page）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-17.png)

在启动页机制后，不可能在取消段机制后只保留页机制

## 了解ucore建立段/页表

### x86 MMU - 页机制概述

![](img\操作系统 -- 第七讲 实验二 物理内存管理-18.png)

### x86 MMU - 页机制举例

![](img\操作系统 -- 第七讲 实验二 物理内存管理-19.png)

怎么能够把一个逻辑地址（虚拟地址）转换成一个物理地址

- 需要建好页目录表、页表（都是 4K 大小）

- 让页基址寄存器（CR3）的高 20 位内容为页目录表的高 20 位物理地址

- 高 10 位是 `b1100000100 == 0x304`，也就是说我们需要查 1024 项里面的第 0x304 项

    - 找到这个地方之后呢，这里会存储一个信息，这个信息，比如说存的是 0x233

        0x233 它是按照 4K 来做一个偏移，向右偏移了 12 位，所以我们要将它向左偏移 12 位，形成 0x233000 这么一个地址

        它存的是 Page Table 的一个物理地址的基址，找到这个 Page Table 之后，我们的 CPU 会查中间的 10 位

    - 上述内容也就是在虚地址高 10 位的值为 index 的页目录项中的高 20 位填写页表的高 20 位物理地址，设置有效位

- 中间 10 位是 `b1000110100 == 0x234`，0x234 作为 index，找到 PTE

    - PTE 里面存的是 0x22333，同样他也是按照 4K 对齐，右移了 12 位

        所以我们需要将它左移 12 位得到正确的你所对应的物理页的基址，即 0x22333000

    - 上述内容也就是在虚地址中 10 位的值为 index 的页表项中的高 20 位填写物理页地址的高 20 位物理地址，设置有效位

- 低 12 位是 `b010101100111 == 0x567`，和 0x22333000 合在一起就形成了最终的物理地址

#### 疑问 1（中间 10 位的 0x22333 不是在 PTE 里么，视频说的 PDE）

### x86 MMU - 页表项（page table entries）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-20.png)

第一行是页目录表项，第三行是页表项，一共是 32 位，基址固定占用高 20 位

### x86 MMU - 使能页机制（enable paging）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-21.png)

假定已经建好了页表、页目录表，建好之后我们要使能页机制

需要对 CR0 寄存器里面的 PG 位进行修改，它的最高位是 31 位，它的最低位是用来 enable 保护模式的

CR0 寄存器的第 31 位变为 1 的话就代表启动了页机制，这是需要在内核态访问的寄存器

### x86 MMU - 建立页表（page tables）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-22.png)

- 分配一个 4K 的页来作为一个页目录的 table

- 然后把这个里面的 page 清掉，清掉是为了做初始化

- 建立对应的页表，对一定空间的内存来建立对应关系。为此需要在页目录表和页表里面填好相应的项，映射关系如下

    - 0xC0000000 到 0xF8000000 这块空间会映射到物理地址的 0x00000000 到 0x38000000 这么一个地址

        可以看出来这里的偏移值就是 0xC0000000，这实际上映射的是内核空间

        使得我们内核态的代码和数据都是在 0xC0000000 这个之上的一个空间

    - lab 2 链接是时候用的起始地址就是 0xC0000000

    - 0x00000000 到 0x00100000 的虚拟地址映射到了 0x00000000 到 0x00100000 的物理地址

        这是一个对等映射

- enable 页机制

- 再次更新 GDT（内核启动的时候会更新第一次 GDT）

    更新 GDT 的原因是此时页机制已经启动了，页机制已经完成了 0xC0000000（va） 到 0（pa） 的映射

    那么段机制就只需要完成对等映射了

- 取消 0x00000000 到 0x100000 的映射，这个映射是页机制的映射，把它取消了，前面做了映射这里又取消的原因是什么？

#### 疑问 2（为何取消 0x00000000 到 0x100000 的映射 ）

### x86 MMU - 在页表中建立页的映射关系（作业）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-23.png)

假设页表建立好了，接下来要完成一个特定的内存映射，这时候就需要对 PDE、PTE 做一个处理

甚至是我们这块内存属于另一块空间，而现在页表没有对应上的这么一种情况，我们需要建立一个新的页表

**作业：尝试在已知一个虚拟地址和一个物理地址的情况下，分配一个对应的页表项，使得虚拟地址能够正确地映射到对等的物理地址**

### x86 MMU - 合并段机制+页机制（segmentation+paging）

![](img\操作系统 -- 第七讲 实验二 物理内存管理-24.png)

