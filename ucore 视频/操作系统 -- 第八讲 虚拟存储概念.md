## 虚拟存储的需求背景

### 存储器层次结构

![](img\操作系统 -- 第八讲 虚拟存储概念-1.png)

### 虚拟存储需求

- 计算机系统时常出现**内存空间不够用**

    - 覆盖（overlay）

        应用程序**手动**把需要的指令和数据保存在内存中

    - 交换（swapping）

        操作系统**自动**把暂时不能执行的程序保存到外存中

    - 虚拟存储

        在有限容量的内存中，以页为单位**自动**装入**更多更大**的程序

## 覆盖和交换

### 覆盖技术

- 目标

    - 在较小的可用内存中运行较大的程序

- 方法

    依据程序逻辑结构，将程序划分为若干**功能相对独立**的模块；

    将不会同时执行的模块**共享同一块内存区域**

    - 必要部分（常用功能）的代码和数据常驻内存
    - 可选部分（不常用功能）放在其他程序模块中，只在需要用到时装入内存
    - 不存在调用关系的模块可互相覆盖，共用同一块内存区域

### 交换技术

- 目标
    - 增加正在运行或需要运行的程序的内存
- 实现方法
    - 可将暂时不能运行的程序放到外存
    - 换入换出的基本单位
        - 整干进程的地址空间
    - 换出（swap out）
        - 把一个进程的整个地址空间保存到外存
    - 换入（swap in）
        - 将外存中某进程的地址空间读入到内存

### 交换技术面临的问题

- 交换时机：何时需要发生交换？
    - 只有当内存空间不够或有不够的可能时换出
- 交换区大小
    - 存放所有用户进程的所有内存映像的拷贝
- 程序换入时的重定位：换出后再换入时要放在原处吗？
    - 采用动态地址映射的方法

### 覆盖与交换的比较

- 覆盖
    - 只能发生在没有调用关系的模块间
    - 程序员须给出模块间的逻辑覆盖结构
    - 发生在运行程序的内部模块间
- 交换
    - 以进程为单位
    - 不需要模块间的逻辑覆盖结构
    - 发生在内存进程间

## 局部性原理

### 虚拟存储技术的目标

![](img\操作系统 -- 第八讲 虚拟存储概念-2.png)

### 局部性原理（principle of locality）

- 程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域

    - 时间局部性

        - 一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短的时期内

    - 空间局部性

        - 当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内

    - 分支局部性

        - 一条跳转指令的两次执行，很可能跳到相同的内存位置
- 局部性原理的意义
    - 从理论上来说，虚拟存储技术是能够实现的，而且可取得满意的效果

### 不同程序编写方法的局部性特征

![](img\操作系统 -- 第八讲 虚拟存储概念-3.png)

![](img\操作系统 -- 第八讲 虚拟存储概念-4.png)

图里竖着的是每一页，横着的是每一页里面的块

解法一里每一次相邻的访问都会切到下一页，这种切换会导致一次缺页，所以总共的缺页次数是 1024 × 1024

如果这些数据全在内存里头，那么这两种做法消耗的时间是一样的

如果在这里考虑到物理内存的量小，那么这两种做法就有很大的差异，所以在利用虚拟存储之后要对代码的写法多加注意

## 虚拟存储概念

### 虚拟存储的基本概念

- 思路
    - 将不常用的部分内存块暂存到外存
- 原理
    - 装载程序时
        - 只将当前指令执行需要的部分页面或段装入内存
    - 指令执行中需要的指令或数据不在内存（称为缺页或缺段）时
        - 处理器通知操作系统将相应的页面或段调入内存
    - 操作系统将内存中暂时不用的页面或段保存到外存
- 实现方式
    - 虚拟页式存储
    - 虚拟段式存储

### 虚拟存储的基本特征

- 不连续性
    - 物理内存分配非连续
    - 虚拟地址空间使用非连续
- 大用户空间
    - 提供给用户的虚拟内存可大于实际的物理内存
- 部分交换
    - 虚拟存储只对部分虚拟地址空间进行调入和调出

### 虚拟存储的支持技术

- 硬件
    - 页式或短时存储中的地址转换机制
- 操作系统
    - 管理内存和外存页面或段的换入和换出

## 虚拟页式存储

### 虚拟页式存储管理

- 在页式存储管理的基础上，增加请求调页和页面置换
- 思路
    - 当用户程序要装载到内存运行时，只装入部分页面。就启动程序运行
    - 进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求
    - 操作系统在处理缺页异常时，将外存中相应的页面调入内存，值得进程能继续运行

### 虚拟页式存储中的地址转换

![](img\操作系统 -- 第八讲 虚拟存储概念-5.png)

基本与页式存储管理的流程一样，区别在于虚拟页式存储的地址转换中，会在页表里多加一个标志位

这个标志位代表的是对应的这一页是否在物理内存里头，如果不在，就不能转换成物理地址了，随即产生缺页异常

这个缺页异常会由操作系统来接管，操作系统就会找页把页表写好，然后把标志位变为有效

### 虚拟页式存储中的页表结构

![](img\操作系统 -- 第八讲 虚拟存储概念-6.png)

- 驻留位：表示该页是否在内存
    - 1 表示该页位于内存中，该页表项是有效的，可以使用
    - 0 表示该页当前在外存中，访问该页表项将导致缺页异常
- 修改位：表示在内存中的该页是否被修改过
    - 回收该物理页面时，据此判断是否要把它的内容写回外存
- 访问位：表示该页面是否被访问过（读或写）
    - 用于页面置换算法
- 保护位：表示该页的允许访问方式
    - 只读、可读写、可执行等

### 虚拟页式存储示例

![](img\操作系统 -- 第八讲 虚拟存储概念-7.png)

X 是没有映射过来的地址

### X86 页表结构

![](img\操作系统 -- 第八讲 虚拟存储概念-8.png)

32 位的 x86 系统的逻辑地址中有 12 位的页内偏移，有 2 个 10 位的二级页表项

32 位的物理地址中的 20 位是物理页帧号

页表项的起始地址是 CR3 提供的，4K 为一页，一页里有 1024 个页表项，正好对应逻辑地址的高 10 位

### X86 页表项结构

![](img\操作系统 -- 第八讲 虚拟存储概念-9.png)

## 缺页异常









asd

