## 页面置换算法的概念

### 置换算法的功能和目标

- 功能
    - 当出现缺页异常，需调用新页面而内存已满时，置换算法**选择被置换的物理页面**
- 设计目标
    - 尽可能**减少页面的调入调出次数**
    - 把未来不再访问或短期内不访问的页面调出
- 页面锁定（frame locking）
    - 描述必须常驻内存的逻辑页面
    - 操作系统的关键部分
    - 要求相应速度的代码和数据
    - 页表中的锁定标志位（lock bit）

### 置换算法的评价方法

- 记录进程访问内存的页面轨迹

    - 举例：虚拟地址访问用（页号，位移）表示

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3, 0), (1, 9), (4, 1), (2, 1), (5, 3), (2, 0), (1, 9),

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2, 4), (3, 1), (4, 8)
        
    - 对应的页面轨迹
    
        3, 1, 4, 2, 5, 2, 1, 2, 3, 4
    
        替换如 c, a, d, b, e, b, a, b, c, d
    
- 评价方法

    - 模拟页面置换行为，记录产生缺页的次数
    - 更少的缺页，更好的性能

### 页面置换算法分类

- 局部页面置换算法
    - 置换页面的选择范围仅限于当前进程占用的物理页面内
    - 最优算法、先进先出算法、最近最久未使用算法
    - 时钟算法、最不常用算法
- 全局页面置换算法
    - 置换页面的选择范围是所有可换出的物理页面
    - 工作集算法、缺页率算法

## 最优算法、先进先出算法和最近最久未使用算法

### 最优页面置换算法（OPT, optional）

- 基本思路
    - 置换在未来最长时间不访问的页面
- 算法实现
    - 缺页时，计算内存中每个逻辑页面的下一次访问时间
    - 选择**未来最长时间不访问的页面**
- 算法特征
    - 缺页最少，是理想情况
    - 实际系统中**无法实现**
    - 无法预测每个页面在下次访问前的等待时间
    - 作为置换算法的性能评价依据
        - 在模拟器上运行某个程序，并记录每一次的页面访问情况
        - 第二遍运行时使用最优算法

### 最优页面置换算法示例

![](img\操作系统 -- 第九讲 页面置换算法-1.png)

时间 5 之所以把 d 替换成 e 是因为在将要用到的进程中，d 是离得最远的

这里缺页次数出现了 2 次

### 先进先出算法（First-In First-Out FIFO）

- 思路
    - 选择在**内存驻留时间最长**的页面进行置换
- 实现
    - 维护一个记录所有位于内存中的逻辑页面链表
    - 链表元素按驻留内存的时间排序，链首最长，链尾最短
    - 出现缺页时，选择链首页面进行置换，新页面加到链尾
- 特征
    - 实现简单
    - 性能较差，调出的页面可能是经常访问的
    - 进程分配物理页面数增加时，缺页并不一定减少（Belady 现象）
    - 很少单独使用

### FIFO

![](img\操作系统 -- 第九讲 页面置换算法-2.png)

入栈顺序是 `a → b → c → d`，所以替换流程如下

- 替换 a 为 e，此时 e 入栈
- 替换 b 为 a，此时 a 入栈
- 替换 c 为 b，此时 b 入栈
- 替换 d 为 c，此时 c 入栈
- 替换 e 为 d，此时 d 入栈

这里缺页出现了 5 次，从而可见最优页面置换算法的优越性

### 最近最久未使用算法（Least Recently Used, LRU）

- 思路
    - 选择**最长时间没有被引用**的页面进行置换
    - 如某些页面长时间未被访问，则它们在将来还可能会长时间不会访问
- 实现
    - 缺页时，计算内存中每个逻辑页面的**上一次**访问时间
    - 选择**上一次使用到当前时间最长的页面**
- 特征
    - 最优置换算法的一种近似

### 最近最未被使用算法(LRU)

![](img\操作系统 -- 第九讲 页面置换算法-3.png)

每次找每个元素最近一次出现的时间，时间最小的那个被替换

### LRU 算法的可能实现方法

- 页面链表
    - 系统维护一个按最近一次访问时间排序的页面链表
        - 链表首节点是最近刚刚使用过的页面
        - 链表尾节点是最久未使用的页面
    - 访问内存时，找到相应页面，并把它移到链表之首
    - 缺页时，置换链表尾节点的页面
- 活动页面栈
    - 访问页面时，将此页号压入栈顶，并将栈内相同的页号抽出
    - 缺页时，置换栈底的页面
- 特征
    - 开销比较大

### 用栈实现 LRU 算法

![](img\操作系统 -- 第九讲 页面置换算法-4.png)

也是拿栈来实现，不过这里是按访问请求的元素进行压栈（或者是把元素抽出来放到栈顶），缺页时就置换掉栈底的页面

## 时钟置换算法和最不常用算法

### 时钟置换算法（Clock）

- 思路
    - 仅对页面的访问情况进行大致统计
- 数据结构
    - 在页表项中增加**访问位**，描述页面在过去一段时间内的访问情况
    - 各页面组织成**环形链表**
    - **指针**指向最先调入的页面
- 算法
    - 访问页面时，在页表项记录页面访问情况
    - 缺页时，从指针处开始顺序查找未被访问的页面进行置换
- 特征
    - 时钟算法是 LRU 和 FIFO 的折中

### 时钟置换算法的实现

- 页面装入内存时，访问位初始化为 0
- 访问页面（读/写）时，访问位置 1
- 缺页时，从指针当前位置顺序检查环形链表
    - 访问位为 0，则置换该页
    - 访问位为 1，则访问位置 0，并指针移动到下一个页面，直到找到可置换的页面

### 时钟置换算法图示

**初始状态**

![](img\操作系统 -- 第九讲 页面置换算法-5.png)

**第一次时钟置换算法执行后的状态**

![](img\操作系统 -- 第九讲 页面置换算法-6.png)

顺时针扫描，访问位是 1 的在被扫描之后都变成 0（从当前节点开始）；访问位是 0 的将帧号置换，然后将访问位的值修改成 1

### 时钟页面置换示例

![](img\操作系统 -- 第九讲 页面置换算法-7.png)

### 改进的 Clock 算法

- 思路
    - 减少修改页的缺页处理开销
- 算法
    - 在页面中增加修改位，并在访问时进行相应修改
    - 缺页时，修改页面标志位，以跳过有修改的页面

![](img\操作系统 -- 第九讲 页面置换算法-8.png)

### 增强的 Clock 算法

![](img\操作系统 -- 第九讲 页面置换算法-9.png)

### 最不常用算法（Least Frequently Used, LFU）

- 思路
    - 缺页时，置换访问次数最少的页面
- 实现
    - 每个页面设置一个访问计数
    - 访问页面时，访问计数加 1
    - 缺页时，置换计数最小的页面
- 特征
    - 算法开销大
    - 开始时频繁使用，但以后不使用的页面很难置换
        - 解决方法：计数定期右移
- LRU 和 LFU 的区别
    - LRU 关注**多久未访问**，时间越短越好
    - LFU 关注**访问次数**，次数越多越好

### LFU 算法示例

![](img\操作系统 -- 第九讲 页面置换算法-10.png)

## Belady 现象和局部置换算法比较

### Belady 现象

- 现象
    - 采用 FIFO 等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象
- 原因
    - FIFO 算法的置换特征与进程访问内存的动态特征矛盾
    - 被它置换出去的页面并不一定是进程近期不会访问的
- 思考
    - 哪些置换算法没有 Belady 现象？

### FIFO 算法有 Belady 现象

![](img\操作系统 -- 第九讲 页面置换算法-11.png)

![](img\操作系统 -- 第九讲 页面置换算法-12.png)

### LRU 算法没有 Belady 现象

![](img\操作系统 -- 第九讲 页面置换算法-13.png)

### LRU、FIFO 和 Clock 的比较

- LRU 算法和 FIFO 本质上都是先进先出的思路
    - LRU 依据页面的最近访问时间排序
    - LRU 需要动态地调整顺序
    - FIFO 依据页面进入内存的时间排序
    - FIFO 的页面进入时间是固定不变的
- LRU 可退化成 FIFO
    - 如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同
    - 例如：给进程分配 3 个物理页面，逻辑页面的访问顺序为 1、2、3、4、5、6、1、2、3...
- LRU 算法性能较好，但系统开销较大
- FIFO 算法系统开销较小，会发生 Belady 现象
- Clock 算法是它们的折中
    - 页面访问时，不动态调整页面在链表中的顺序，仅做标记
    - 缺页时，再把它移动到链表末尾
- 对于未被访问的页面，Clock 和 LRU 算法的表现一样好
- 对于被访问过的页面，Clock 算法不能记录准确访问顺序，而 LRU 算法可以

## 工作集置换算法

### 局部置换算法没有考虑进程访存差异

**物理页面数： 3**

![](img\操作系统 -- 第九讲 页面置换算法-14.png)

**物理页面数：4**

![](img\操作系统 -- 第九讲 页面置换算法-15.png)

可以看到多加一页可以避免缺页现象的发生

### 全局置换算法

- 思路
    - 全局置换算法为进程分配**可变数目**的物理页面
- 全局置换算法要解决的问题
    - 进程在不同阶段的内存寻求是变化的
    - 分配给进程的内存也需要在不同的阶段有所变化
    - 全局置换算法需要确定分配给进程的物理页面数

### CPU 利用率与并发进程数的关系

<img src="img\操作系统 -- 第九讲 页面置换算法-16.png" style="zoom: 33%;" />

- CPU 利用率与并发进程数存在相互促进和制约的关系
    - 进程数少时，提高并发进程数，可提高 CPU 利用率
    - 并发进程导致内存访问增加
    - 并发进程的内存访问会降低了访存的局部性特征
    - 局部性特征的下降会导致缺页率上升和 CPU 利用率下降

### 工作集

一个进程当前正在使用的逻辑页面集合，可表示为二元函数 W(t, Δ)

- t 是当前的执行时刻
- Δ 称为工作集窗口（working-set window），即一个定长的页面访问时间窗口
- W(t, Δ) 是指在当前时刻 t 前的 Δ 时间窗口中的所有访问页面所组成的集合
- |W(t, Δ)| 指工作集的大小，即页面数目

### 进程的工作集示例

![](img\操作系统 -- 第九讲 页面置换算法-17.png)

### 工作集的变化

<img src="img\操作系统 -- 第九讲 页面置换算法-18.png" style="zoom:33%;" />

- 进程开始执行后，随着访问新页面逐步建立较稳定的工作集
- 当内存访问的局部性区域的位置**大致稳定**时，工作集大小也大致稳定
- 局部性区域的位置改变时，工作集**快速扩张和收缩**过渡到下一个稳定值

### 常驻集

在当前时刻，进程实际驻留在内存当中的页面集合

- 工作集和常驻集的关系
    - 工作集是进程在运行过程中固有的性质
    - 常驻集取决于系统分配给进程的物理页面数目和页面置换算法
- 缺页率与常驻集的关系
    - 常驻集 ⊇ 工作集时，缺页较少
    - 工作集发生剧烈变动（过渡）时，缺页较多
    - 进程常驻集大小达到一定数目后，缺页率也不会明显下降

### 工作集置换算法

- 思路
    - 换出不在工作集中的页面
- 窗口大小 τ
    - 当前时刻前 τ 个内存访问的页引用是工作集，τ 被称为窗口大小
- 实现方法
    - 访存链表：维护窗口内的访存页面链表
    - 访存时，换出不在工作集的页面；更新访存链表
    - 缺页时，换入页面；更新访存链表

![](img\操作系统 -- 第九讲 页面置换算法-19.png)

横着看有哪些页面，范围是 τ 个；0 下标下面所指的是一开始的元素顺序

## 缺页率置换算法

### 缺页率（page fault rate）

缺页次数 / 内存访问次数 或 缺页平均实际间隔的倒数

- 影响缺页率的因素
    - 页面置换算法
    - 分配给进程的物理页面数目
    - 页面大小
    - 程序的编写方法

### 缺页率置换算法（PFF, Page-Fault-Frequency）

<img src="img\操作系统 -- 第九讲 页面置换算法-20.png" style="zoom:33%;" />

通过调节常驻集大小，是每个进程的缺页率保持在一个合理的范围内

- 若进程缺页率过高，则增加常驻集以分配更多的物理页面
- 若进程缺页率过低，则减少常驻集以减少它的物理页面数

### 缺页率置换算法的实现

- 访存时，设置引用位标志
- 缺页时，计算从上次缺页时间 **t<sub>last</sub>** 到现在 **t<sub>current</sub>** 的时间间隔
    - 如果  **t<sub>current</sub> - t<sub>last</sub> > T**，则置换所有在 [ **t<sub>last</sub>**, **t<sub>current</sub>** ] 时间内没有被引用的页
    - 如果  **t<sub>current</sub> - t<sub>last</sub> ≤ T**，则增加缺失页到常驻集中

### 缺页率置换算法示例

![](img\操作系统 -- 第九讲 页面置换算法-21.png)

## 抖动和负载控制

### 抖动问题（thrashing）

- 抖动
    - 进程物理页面太少，不能包含工作集
    - 造成大量缺页，频繁置换
    - 进程运行速度变慢
- 产生抖动的原因
    - 随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升
- 操作系统需在并发水平和缺页率之间达到一个平衡
    - 选择一个适当的进程数目和进程需要的物理页面数

### 负载控制

![](img\操作系统 -- 第九讲 页面置换算法-22.png)